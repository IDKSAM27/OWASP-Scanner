1. Approach for Detecting Clickjacking:

Clickjacking is a client-side vulnerability, but the defense is server-side. The scan is therefore a 
straightforward check of server configuration.

    - Principle: The goal is to determine if the web server has implemented the correct HTTP security headers to 
    prevent the target page from being embedded inside a malicious frame or <iframe>.

Methodology:

    1. Request: Your scanner will make a standard HTTP GET request to the target URL.

    2. Header Inspection: The core of the test is to parse the HTTP response headers received from the server.

    3. Analysis: The scanner must check for two specific headers in order of preference:

        - Content-Security-Policy (CSP): This is the modern standard. The scanner looks for the frame-ancestors 
        directive. Secure configurations include frame-ancestors 'none' (most secure, prevents all framing) or 
        frame-ancestors 'self' (allows framing only by pages from the same origin). The absence of this directive, 
        or a weak configuration like frame-ancestors *, is a vulnerability.

        - X-Frame-Options: This is a legacy header. If CSP is not present, the scanner checks for this. Secure values 
        are DENY or SAMEORIGIN. The absence of this header (when CSP frame-ancestors is also absent) indicates the 
        application is vulnerable.

==========================================================================================================================================

2. Approach for Detecting Directory Traversal:

This test attempts to trick the application into accessing files from outside the intended web root directory.

    - Principle: Identify and exploit URL parameters that the application uses to reference files on the local disk.

Methodology:

    1. Discovery: First, your application must crawl the target website to find potential vectors. It will look for URL 
    parameters that suggest file handling, such as ?page=intro.php, ?file=userguide.pdf, or ?view=image.jpg.

    2. Payload Generation: The scanner will use a list of specially crafted path traversal strings. A professional 
    tool will include multiple encodings to bypass basic filters.

        - Standard Payloads: ../../../../etc/passwd (Linux), ../../../../boot.ini (Windows)

        - URL Encoded: %2e%2e%2f for ../, and even double URL encoding like %252e%252e%252f.

        - Non-standard and UTF-8 Encoded: ..%c0%af and other tricky variations.

    3. Execution & Analysis: For each discovered parameter, the scanner replaces the original value with a traversal 
    payload and sends the modified request.

    4. Detection Logic: It confirms a vulnerability by analyzing the response:

        - Content-Based: The most reliable sign is a 200 OK status code where the response body contains content 
        from the targeted sensitive file (e.g., root:x:0:0 for /etc/passwd).

        - Error-Based: Specific error messages can also reveal a vulnerability even if the file isn't successfully read. 
        For instance, an error like "File not found: /var/www/images/../../etc/passwd" confirms that the application is processing 
        the traversal sequence.

==========================================================================================================================================

3. Approach for Detecting Cross-Site Scripting (XSS): 

Detecting XSS requires simulating an attacker's attempt to inject a script and have the server reflect it back to be executed 
by a browser.

    - Principle: Determine if the application properly sanitizes user-supplied input before embedding it in an HTML response.

Methodology:

    1. Discovery: Crawl the application to find all possible input vectors. This includes URL parameters (both GET and POST), 
    form fields, and even HTTP headers like User-Agent or Referer that are sometimes reflected on a page.

    2. Contextual Payload Injection: A professional scanner does not use a single <script>alert(1)</script> payload. It injects payloads 
    that are specific to the context in which the input is reflected.

        - HTML Tag Context: If input is reflected between tags (<div>[input]</div>), use <script>...</script>.

        - HTML Attribute Context: If input is in an attribute (<input value="[input]">), use payloads like "><script>...</script>.

        - JavaScript Context: If input is inside a script (var name = '[input]';), use payloads like ';alert(1)//.

    3. Analysis (The Critical Step):

        - Static Analysis: The first pass involves checking the raw HTML response to see if the payload is reflected back unsanitized. 
        This is fast but prone to false positives.

        - Dynamic Analysis (Headless Browser): For high confidence, the scanner must use a headless browser (e.g., via Selenium or Playwright). 
        It submits the payload, then renders the resulting page in the headless browser. The tool then listens for evidence of JavaScript 
        execution (like a window.alert or a custom function call). This is the definitive way to confirm DOM-based and stored XSS and 
        eliminate false positives.

==========================================================================================================================================

4. Approach for Detecting SQL Injection (SQLi):

This is one of the most complex but critical checks. It involves trying to manipulate the database queries an application makes.

    - Principle: Determine if user input is being passed directly into SQL queries without proper sanitization or the use of 
    parameterized queries.

Methodology:

    1. Discovery: Identify all user input parameters, same as with XSS.

    2. Injection and Detection: A professional scanner will test for multiple types of SQLi sequentially, as some are much "louder" 
    than others.

        - Error-Based SQLi: This is the first test. The scanner injects syntax-breaking characters like a single quote (') or a 
        double quote ("). It then analyzes the response for database-specific error messages (e.g., You have an error in your SQL syntax, 
        ORA-00942, etc.). This provides a quick and clear sign of a vulnerability.

        - Boolean-Based Blind SQLi: If error-based fails, the scanner moves to a more subtle method. It injects a logical condition that 
        will resolve to true or false. For example: AND '1'='1 and AND '1'='2. The scanner compares the response pages. If the "true" 
        condition returns a normal page and the "false" condition returns a different page, it confirms the injection.

        - Time-Based Blind SQLi: This is the final and most definitive test. If the page content doesn't change, the scanner injects a 
        command that forces the database to wait. For example: AND SLEEP(5). The scanner then measures the server's response time. 
        If the response is delayed by approximately 5 seconds, it proves with very high confidence that the database executed the 
        injected command.